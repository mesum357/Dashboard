<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tourist Data</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <link rel="stylesheet" href="/css/tourist_data.css">
    <style>
        /* Camera modal styles */
        #cameraModal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background-color: rgba(0, 0, 0, 0.9);
            z-index: 1000;
            justify-content: center;
            align-items: center;
        }

        #cameraModal {
            width: 100vw;
            height: 100vh;
        }

        #cameraContainer {
            width: 60vw;
            height: 60vh;
            max-width: 60vw;
            max-height: 60vh;
            margin: auto;
            background-color: transparent;
            padding: 0;
            border-radius: 0;
            display: flex;
            flex-direction: column;
            justify-content: flex-start;
            align-items: center;
            position: relative;
        }

        #videoPreview {
            width: 60vw;
            height: 60vh;
            max-width: 60vw;
            max-height: 60vh;
            border: none;
            border-radius: 10px;
            background: #000;
            object-fit: contain;
        }
        #detectionOverlay {
            position: absolute;
            top: 0;
            left: 0;
            pointer-events: none;
        }
        #cameraInfo {
            position: absolute;
            top: 8px;
            left: 8px;
            padding: 6px 10px;
            border-radius: 8px;
            background: rgba(0,0,0,0.6);
            color: #fff;
            font-size: 12px;
            line-height: 1;
            z-index: 3;
        }

        #cameraButtons {
            position: absolute;
            left: 0;
            bottom: 0;
            width: 60vw;
            display: flex;
            justify-content: center;
            gap: 20px;
            margin: 0 0 12px 0;
            z-index: 2;
        }

        #takePhotoBtn, #closeCameraBtn {
            padding: 16px 32px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 18px;
        }

        #takePhotoBtn {
            background-color: #B06C5D;
            color: white;
        }

        #closeCameraBtn {
            background-color: #f1f1f1;
            color: #333;
        }

        #takePhotoBtn:hover {
            background-color: #9a5a4e;
        }

        #closeCameraBtn:hover {
            background-color: #e0e0e0;
        }
        /* Subadmin sidebar fix */
        .subadmin-sidebar {
            width: 250px;
            position: fixed;
            left: 0;
            top: 0;
            height: 100vh;
            background: #081c3a;
            color: white;
            z-index: 100;
        }
       
        @media (max-width: 768px) {
            .subadmin-sidebar {
                width: 180px;
            }
        }

        /* Foreign passenger fields visibility */
        .number-foreign,
        .number-foreign-females,
        .number-foreign-males {
            display: none;
        }

        .number-foreign.show,
        .number-foreign-females.show,
        .number-foreign-males.show {
            display: block;
        }

        /* Table responsive styles */
        .table-responsive-wrapper {
            width: 100%;
            overflow-x: auto;
            margin-top: 20px;
        }

        /* Fix for subadmin view - section-2 should not have extra margin */
        .section-2 {
            width: 100%;
            box-sizing: border-box;
            padding: 20px;
        }

        .previous-data-table {
            width: 100%;
            border-collapse: collapse;
            min-width: 600px; /* Minimum width to prevent squishing */
        }

        .previous-data-table th,
        .previous-data-table td {
            padding: 12px;
            text-align: left;
            border-bottom: 1px solid #ddd;
            white-space: nowrap;
        }

        .previous-data-table th {
            background-color: #f5f5f5;
            font-weight: bold;
        }

        .previous-data-table tr:hover {
            background-color: #f9f9f9;
        }

        /* Ensure main content doesn't overflow */
        .main-content-with-subadmin {
            padding: 20px;
            width: calc(100% - 250px);
            box-sizing: border-box;
        }

        @media (max-width: 768px) {
            .main-content-with-subadmin {
                width: calc(100% - 180px);
            }
        }
        @keyframes spin { 100% { transform: rotate(360deg); } }
        #ocrStatus {
            max-width: 90vw;
            min-width: 180px;
            font-size: 1rem;
            word-break: break-word;
        }
        @media (max-width: 768px) {
            #videoPreview {
                height: 70vh;
                max-height: 70vh;
            }
            #cameraButtons {
                flex-direction: column;
                gap: 10px;
                margin-bottom: 12px;
            }
        }
        @media (max-width: 768px) {
            #cameraContainer {
                width: 96vw;
                height: 50vh;
                max-width: 96vw;
                max-height: 50vh;
            }
            #videoPreview {
                width: 96vw;
                height: 50vh;
                max-width: 96vw;
                max-height: 50vh;
            }
            #cameraButtons {
                width: 96vw;
                flex-direction: column;
                gap: 10px;
                margin-bottom: 6px;
            }
        }
    </style>
</head>
<body>
    
<% if (value === 1) { %>
    <%- include('sidebar') %>
    <style>
        .section-2{
            margin-left: 250px;
        }
    </style>
<% } else if (value === 2) { %>
    <div class="subadmin-sidebar">
        <%- include('subadmin-sidebar') %>
    </div>
    <div class="main-content-with-subadmin">
<% } else { %>
    <% console.log("Error") %>
<% } %>

    <form action="/upload" method="POST" enctype="multipart/form-data">
        <div class="order-info">
            <div class="order-date">
                <label>Order Date</label>
                <input type="text" name="orderDate" value="<%= new Date().toLocaleDateString() %>" readonly required>
            </div>
            <div class="order-time"> 
                <label>Time</label>
                <input type="text" name="orderTime" value="<%= new Date().toLocaleTimeString() %>" readonly required>
            </div>
            <div class="order-time">
                <label>Location</label>
                <% if (typeof isSubAdmin !== 'undefined' && isSubAdmin) { %>
                  <input type="text" name="location" id="location" value="<%= region %>" readonly style="width: 100%; padding: 7px 10px; border: none; border-radius: 5px; background-color: #f0f0f0; color: #333; font-size: 16px; cursor: not-allowed;">
                <% } else { %>
                  <select name="location" id="location" required style="width: 100%; padding: 7px 10px; border: none; border-radius: 5px; background-color: #f0f0f0; color: #333; font-size: 16px; cursor: pointer;">
                    <option value="Karachi">Gilgit</option>
                    <option value="Lahore">Hunza</option>
                    <option value="Islamabad">Skardu</option>
                    <option value="Peshawar">Chalt</option>
                    <option value="Quetta">Ghizer</option>
                  </select>
                <% } %>
            </div>
            <div class="vehicle-number">
                <label>Vehicle Number</label>
                <input type="text" name="vehicleNumber" id="vehicleNumber" required>
            </div>
            <div class="vehicle-number">
                <label>CNIC Number <span style="font-size: 12px; color: #666;">(Without Dashes)</span></label>
                <input type="text" name="cnic" id="cnicNumber" required>
                <div id="ocrStatus"></div>
            </div>
        </div>

        <div class="personal-info">
            <h3>Personal Information</h3>
            <div class="data-main">
                <div class="personal-info-main">
                    <div class="profile-image">
                        <label>CNIC Image</label>
                        <div class="image-upload">
                            <div class="upload-container">
                                <img src="/assets/images/Input.png" alt="Profile Preview" id="profilePreview">
                                <input type="file" name="profileImage" id="profileInput" accept="image/*" capture="environment" onchange="previewImage(this, 'profilePreview');">
                                <label for="profileInput" class="upload-label">Choose File</label>
                                <button type="button" onclick="openCamera('profile')">Capture Image</button>
                            </div>
                        </div>
                    </div>
                    <div class="driving-license">
                        <label>Driving License</label>
                        <div class="image-upload">
                            <div class="upload-container">
                                <img src="/assets/images/Input.png" alt="License Preview" id="licensePreview">
                                <input type="file" name="drivingLicenseImage" id="licenseInput" accept="image/*" capture="environment" onchange="previewImage(this, 'licensePreview')">
                                <label for="licenseInput" class="upload-label">Choose File</label>
                                <button type="button" onclick="openCamera('license')">Capture Image</button>
                            </div>
                        </div>
                    </div>
                    <div class="vehicle-image">
                        <label>Vehicle Image</label>
                        <div class="image-upload">
                            <div class="upload-container">
                                <img src="/assets/images/Input.png" alt="Vehicle Preview" id="vehiclePreview">
                                <input type="file" name="vehicleImage" id="vehicleInput" accept="image/*" capture="environment" onchange="previewImage(this, 'vehiclePreview')">
                                <label for="vehicleInput" class="upload-label">Choose File</label>
                                <button type="button" onclick="openCamera('vehicle')">Capture Image</button>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Camera Modal -->
                <div id="cameraModal" class="modal">
                    <div id="cameraContainer">
                        <h3>Capture Image</h3>
                        <video id="videoPreview" autoplay></video>
                        <canvas id="detectionOverlay"></canvas>
                        <div id="cameraInfo"></div>
                        <div id="cameraButtons">
                            <button type="button" id="takePhotoBtn" onclick="takePhoto(event)">Capture</button>
                            <button type="button" id="closeCameraBtn" onclick="closeCamera()">Close</button>
                        </div>
                    </div>
                </div>

                
                </div>

                <div class="passenger-info-main">
                    <div class="passenger-info">
                        <div class="total-passengers">
                            <label>Total Passengers</label>
                            <input type="number" placeholder="No of Passengers" name="passengers" required>
                        </div>
                        <div class="number-females">
                            <label>Number of Females</label>
                            <input type="number" placeholder="Number of Female Passengers" name="females" required>
                        </div>
                        <div class="number-males">
                            <label>Number of Males</label>
                            <input type="number" placeholder="Number of Male Passengers" name="males" required>
                        </div>
                        <div class="number-foreign">
                            <label>Total Foreign Passengers</label>
                            <input type="number" placeholder="Number of Foreign Passengers" name="foreigners" value="0">
                        </div>
                        <div class="number-foreign-females">
                            <label>Foreign Female Passengers</label>
                            <input type="number" placeholder="Number of Foreign Female Passengers" name="foreignFemales" value="0">
                        </div>
                        <div class="number-foreign-males">
                            <label>Foreign Male Passengers</label>
                            <input type="number" placeholder="Number of Foreign Male Passengers" name="foreignMales" value="0">
                        </div>
                    </div>
                    <div class="vehicle-info">
                        <div class="vehicle-passengers">
                            <h3>Vehicle with Passengers</h3>
                            <input type="checkbox" class="checkbox" id="vehiclePassengersCheckbox">
                            <input type="hidden" name="vehiclePassengers" id="vehiclePassengersHidden" value="no">
                        </div>
                        <div class="vehicle-goods">
                            <h3>Vehicle with Goods</h3>
                            <input type="checkbox" class="checkbox" id="vehicleGoodsCheckbox">
                            <input type="hidden" name="vehicleGoods" id="vehicleGoodsHidden" value="no">
                        </div>
                        <div class="vehicle-foreign">
                            <h3>Vehicle with Foreign Passengers</h3>
                            <input type="checkbox" class="checkbox" id="vehicleForeignCheckbox">
                            <input type="hidden" name="vehicleForeign" id="vehicleForeignHidden" value="no">
                        </div>
                        <div class="type-goods">
                            <label>Type of Goods</label>
                            <input type="text" placeholder="Enter type of goods" name="goods">
                        </div>
                    </div>
                </div>
            </div>
<% if(value === 1) { %>
    <button type="submit" class="save-data" name="submit" value="admin">Save Data</button>
<% } else if(value === 2) { %>
    <button type="submit" class="save-data" name="submit" value="subadmin">Save Data</button>
<% } else { %>
    <% console.log("Error") %>
<% } %>
        </div>
    </form>

    <!-- Load Tesseract.js for client-side OCR -->
    <script src="https://unpkg.com/tesseract.js@5.0.3/dist/tesseract.min.js"></script>

    <!-- SECTION 2 -->
    <div class="section-2">
        <h3>Previous Data</h3>
        <div class="table-responsive-wrapper">
            <table class="previous-data-table">
                <thead>
                    <tr>
                        <th>SL No</th>
                        <th>Order No</th>
                        <th>Time</th>
                        <th>Vehicle No</th>
                        <th>Females</th>
                        <th>Males</th>
                        <th>Total Pass</th>
                    </tr>
                </thead>
                <tbody>
                    <% if (typeof data !== 'undefined' && data.length > 0) { %>
                        <% data.forEach((upload, index) => { %>
                            <tr style="cursor: pointer;" 
                                onclick="window.location.href='<%= value === 1 ? `/tourist_info/${upload.srNo}` : `/tourists/${upload.srNo}` %>'">
                                <td><%= upload.srNo %></td>
                                <td><%= upload.orderNo %></td>
                                <td><%= upload.time %></td>
                                <td><%= upload.vehicleNumber %></td>
                                <td><%= upload.females || 0 %></td>
                                <td><%= upload.males || 0 %></td>
                                <td><%= upload.passengers || ((upload.males || 0) + (upload.females || 0)) %></td>
                                <input type="hidden" name="no" value="<%= upload.srNo %>">
                            </tr>
                        <% }); %>
                    <% } else { %>
                        <tr>
                            <td colspan="8" style="text-align: center; padding: 20px;">No previous data available.</td>
                        </tr>
                    <% } %>
                </tbody>
            </table>
        </div>

    </div>
    <!-- Reset OCR scripts -->
    <script>
        // Configurable CNIC regex (Pakistan format #####-#######-#). Allow optional spaces/hyphens in OCR text
        window.CNIC_REGEX = /(\d{5})[-\s]?(\d{7})[-\s]?(\d)/;
        // Enable verbose OCR debugging in console
        window.OCR_DEBUG = true;

        // Tesseract worker and base params
        let ocrWorker = null;
        const baseOcrParams = {
            tessedit_char_whitelist: '0123456789- ',
            tessedit_pageseg_mode: '7', // Treat image as a single text line
            preserve_interword_spaces: '1',
            user_defined_dpi: '300'
        };
        async function ensureOcrWorker() {
            if (ocrWorker) return ocrWorker;
            const status = document.getElementById('ocrStatus');
            try {
                if (status) { status.style.color = '#333'; status.textContent = 'Loading OCR...'; }
                const t0 = performance.now();
                ocrWorker = await Tesseract.createWorker('eng');
                await ocrWorker.setParameters(baseOcrParams);
                const t1 = performance.now();
                debugLog('OCR worker ready', { durationMs: Math.round(t1 - t0) });
                if (status) { status.style.color = '#228b22'; status.textContent = 'OCR ready'; }
            } catch (e) {
                console.error(e);
                if (status) { status.style.color = '#ef4444'; status.textContent = 'Failed to load OCR'; }
            }
            return ocrWorker;
        }
const vehicleNumberInput = document.getElementById('vehicleNumber');
vehicleNumberInput.addEventListener('input', function() {
    this.value = this.value.toUpperCase();
});


        function previewImage(input, previewId) {
            const preview = document.getElementById(previewId);
            if (input.files && input.files[0]) {
                const reader = new FileReader();
                reader.onload = function(e) {
                    preview.src = e.target.result;
                }
                reader.readAsDataURL(input.files[0]);
            } else {
                preview.src = '/assets/images/Input.png';
            }
        }

        // Camera functionality
        let cameraStream = null;
        let currentCaptureTarget = null;

        function openCamera(target) {
            currentCaptureTarget = target;
            document.getElementById('cameraModal').style.display = 'flex';
            startCamera();
        }

        async function startCamera() {
            try {
                if (cameraStream) {
                    cameraStream.getTracks().forEach(track => track.stop());
                }

                const stream = await getHighResStream();
                cameraStream = stream;
                const video = document.getElementById('videoPreview');
                video.srcObject = stream;
                await video.play();

                // Attempt to upgrade the existing track resolution further
                try { await upgradeTrackResolution(stream); } catch (_) {}

                setupDetectionOverlay();
                updateCameraInfo();
                requestAnimationFrame(detectLoop);
            } catch (err) {
                console.error('Error accessing camera:', err);
                alert('Unable to access camera. Please allow camera permissions.');
            }
        }

        async function getHighResStream() {
            const presets = [
                { width: { exact: 2560 }, height: { exact: 1440 }, frameRate: { ideal: 30 } },
                { width: { ideal: 2560 }, height: { ideal: 1440 }, frameRate: { ideal: 30 } },
                { width: { exact: 1920 }, height: { exact: 1080 }, frameRate: { ideal: 30 } },
                { width: { ideal: 1920 }, height: { ideal: 1080 }, frameRate: { ideal: 30 } },
                { width: { ideal: 1280 }, height: { ideal: 720 }, frameRate: { ideal: 30 } }
            ];
            for (const p of presets) {
                const constraints = { video: { ...p, facingMode: { ideal: 'environment' } } };
                try {
                    return await navigator.mediaDevices.getUserMedia(constraints);
                } catch (_) { /* try next */ }
            }
            // Fallback to any camera
            return await navigator.mediaDevices.getUserMedia({ video: true });
        }

        async function upgradeTrackResolution(stream) {
            const track = stream.getVideoTracks && stream.getVideoTracks()[0];
            if (!track || !track.applyConstraints) return;
            const attempts = [
                { width: 2560, height: 1440 },
                { width: 1920, height: 1080 },
                { width: 1280, height: 720 }
            ];
            for (const a of attempts) {
                try {
                    await track.applyConstraints({ advanced: [ { width: a.width, height: a.height, frameRate: 30 } ] });
                    updateCameraInfo();
                    return;
                } catch (_) { /* continue */ }
            }
        }

        function takePhoto(event) {
            event.preventDefault(); // Prevent form submission

            const video = document.getElementById('videoPreview');
            const overlay = document.getElementById('detectionOverlay');
            const canvas = document.createElement('canvas');
            canvas.width = video.videoWidth;
            canvas.height = video.videoHeight;
            const ctx = canvas.getContext('2d');
            ctx.drawImage(video, 0, 0, canvas.width, canvas.height);

            const dataUrl = canvas.toDataURL('image/png');
            let preview, input;
            if (currentCaptureTarget === 'profile') {
                preview = document.getElementById('profilePreview');
                input = document.getElementById('profileInput');
            } else if (currentCaptureTarget === 'license') {
                preview = document.getElementById('licensePreview');
                input = document.getElementById('licenseInput');
            } else if (currentCaptureTarget === 'vehicle') {
                preview = document.getElementById('vehiclePreview');
                input = document.getElementById('vehicleInput');
            }
            if (preview && input) {
                preview.src = dataUrl;
                const fileName = `captured-${Date.now()}.png`;
                const blob = dataUrlToBlob(dataUrl);
                const file = new File([blob], fileName, { type: 'image/png' });
                const dataTransfer = new DataTransfer();
                dataTransfer.items.add(file);
                input.files = dataTransfer.files;
                // If this is the CNIC image, run OCR
                if (currentCaptureTarget === 'profile') {
                    handleCNICImage(input);
                }
            }
            closeCamera();
        }

        function closeCamera() {
            if (cameraStream) {
                cameraStream.getTracks().forEach(track => track.stop());
                cameraStream = null;
            }
            document.getElementById('cameraModal').style.display = 'none';
        }

        function setupDetectionOverlay() {
            const video = document.getElementById('videoPreview');
            const overlay = document.getElementById('detectionOverlay');
            overlay.width = video.clientWidth;
            overlay.height = video.clientHeight;
            overlay.style.width = video.clientWidth + 'px';
            overlay.style.height = video.clientHeight + 'px';
            updateCameraInfo();
        }

		function drawBox(ctx, x, y, w, h, color) {
            ctx.strokeStyle = color;
            ctx.lineWidth = 2;
            ctx.strokeRect(x, y, w, h);
        }

		// Live ROI OCR status
		let roiStatusColor = 'rgba(239,68,68,0.9)'; // red by default
		let lastRoiOcr = 0;
		let isRoiOcrRunning = false;
		const ROI_OCR_INTERVAL_MS = 1000;

		function computeBlurScore(imageData, width, height) {
			// Simple sharpness metric based on gradient magnitude
			const data = imageData.data;
			let sum = 0;
			let count = 0;
			for (let y = 1; y < height - 1; y++) {
				for (let x = 1; x < width - 1; x++) {
					const idx = (y * width + x) * 4;
					const gx = data[idx + 4] - data[idx - 4];
					const gy = data[idx + width * 4] - data[idx - width * 4];
					sum += Math.abs(gx) + Math.abs(gy);
					count++;
				}
			}
			return count ? (sum / count) : 0;
		}

		async function maybeOcrRoi(ts) {
			if (!ocrWorker) return;
			if (isRoiOcrRunning) return;
			if (ts - lastRoiOcr < ROI_OCR_INTERVAL_MS) return;
			lastRoiOcr = ts;
			try {
				isRoiOcrRunning = true;
				const video = document.getElementById('videoPreview');
				if (!video.videoWidth || !video.videoHeight) return;
				// Build ROI from current video frame
				const srcW = video.videoWidth;
				const srcH = video.videoHeight;
				const roiH = Math.round(srcH * 0.18);
				const roiY = Math.round((srcH - roiH) / 2);
				const roiCanvas = document.createElement('canvas');
				// Downscale for speed
				const targetW = Math.min(800, srcW);
				const scale = targetW / srcW;
				roiCanvas.width = targetW;
				roiCanvas.height = Math.round(roiH * scale);
				const roiCtx = roiCanvas.getContext('2d');
				roiCtx.drawImage(video, 0, roiY, srcW, roiH, 0, 0, roiCanvas.width, roiCanvas.height);
				// Light preprocessing
				let img = roiCtx.getImageData(0, 0, roiCanvas.width, roiCanvas.height);
				const d = img.data;
				for (let i = 0; i < d.length; i += 4) {
					const gray = 0.299 * d[i] + 0.587 * d[i + 1] + 0.114 * d[i + 2];
					const v = gray > 160 ? 255 : 0;
					d[i] = d[i + 1] = d[i + 2] = v;
				}
				roiCtx.putImageData(img, 0, 0);
				// Blur score
				img = roiCtx.getImageData(0, 0, roiCanvas.width, roiCanvas.height);
				const blurScore = computeBlurScore(img, roiCanvas.width, roiCanvas.height);
				// Recognize
				const { data } = await ocrWorker.recognize(roiCanvas);
				const text = (data && data.text) ? data.text : '';
				const conf = data && typeof data.confidence === 'number' ? data.confidence : 0;
				const match = text.match(/(\d{5})[-\s]?(\d{7})[-\s]?(\d)/);
				// Heuristics
				const isMatch = !!match;
				const isSharp = blurScore >= 18; // tune if needed
				const isConfident = conf >= 80;
				roiStatusColor = (isMatch && isSharp && isConfident) ? 'rgba(59,130,246,0.9)' : 'rgba(239,68,68,0.9)';
				debugLog('Live OCR:', { conf: Math.round(conf), blur: Math.round(blurScore), match: isMatch, color: roiStatusColor });
			} catch (e) {
				roiStatusColor = 'rgba(239,68,68,0.9)';
			} finally {
				isRoiOcrRunning = false;
			}
		}

        // Remove OCR analysis entirely
        function analyzeFrameForCode() {}

        let lastDrawTs = 0;
        let lastBox = null;
        function detectLoop(ts) {
            const overlay = document.getElementById('detectionOverlay');
            if (!overlay) return;
            const ctx = overlay.getContext('2d', { willReadFrequently: true });
            if (!ctx) return;

            // Throttle drawing a bit
            if (ts && ts - lastDrawTs < 50) {
                requestAnimationFrame(detectLoop);
                return;
            }
            lastDrawTs = ts || performance.now();

            ctx.clearRect(0, 0, overlay.width, overlay.height);
            if (lastBox && lastBox.w > 2 && lastBox.h > 2) {
                drawBox(ctx, lastBox.x, lastBox.y, lastBox.w, lastBox.h, lastBox.color);
            }
            // Draw camera resolution label
            const { label, color } = getResolutionLabel();
            if (label) {
                const badge = document.getElementById('cameraInfo');
                if (badge) {
                    badge.textContent = label;
                    badge.style.border = '1px solid ' + color;
                }
            }
            requestAnimationFrame(detectLoop);
        }

        function getResolutionLabel() {
            const video = document.getElementById('videoPreview');
            if (!video || !video.videoWidth || !video.videoHeight) return { label: '', color: '#888' };
            const w = video.videoWidth;
            const h = video.videoHeight;
            let tag = 'LOW';
            let color = '#ef4444';
            if (w >= 1920 && h >= 1080) { tag = 'HIGH'; color = '#22c55e'; }
            else if (w >= 1280 && h >= 720) { tag = 'MEDIUM'; color = '#f59e0b'; }
            return { label: `${w}x${h} • ${tag} RES`, color };
        }

        function updateCameraInfo() {
            const badge = document.getElementById('cameraInfo');
            if (!badge) return;
            const { label, color } = getResolutionLabel();
            badge.textContent = label || 'Detecting camera...';
            badge.style.border = '1px solid ' + color;
        }

        function dataUrlToBlob(dataUrl) {
            const arr = dataUrl.split(',');
            const mime = arr[0].match(/:(.*?);/)[1];
            const bstr = atob(arr[1]);
            let n = bstr.length;
            const u8arr = new Uint8Array(n);
            while (n--) {
                u8arr[n] = bstr.charCodeAt(n);
            }
            return new Blob([u8arr], { type: mime });
        }

        function debugLog(){
            try {
                if (window && window.OCR_DEBUG) {
                    console.log('[OCR]', ...arguments);
                }
            } catch (_) {}
        }

        // Preload OCR worker when DOM is ready and hook file input change for OCR
        document.addEventListener('DOMContentLoaded', () => {
            if (!window.Tesseract) {
                console.error('Tesseract.js not found on window');
                const status = document.getElementById('ocrStatus');
                if (status) { status.style.color = '#ef4444'; status.textContent = 'OCR library not loaded'; }
            } else {
                debugLog('Tesseract.js available');
                ensureOcrWorker();
            }
            const profileInputEl = document.getElementById('profileInput');
            if (profileInputEl) {
                profileInputEl.addEventListener('change', () => handleCNICImage(profileInputEl));
            }
        });

        // Preprocess image for better OCR: downscale, grayscale, simple threshold
        function preprocessDataURLForOCR(dataUrl) {
            return new Promise(resolve => {
                const img = new Image();
                img.onload = function() {
                    const maxDim = 1400; // try higher initial resolution
                    const origW = img.width;
                    const origH = img.height;
                    let width = origW;
                    let height = origH;
                    const scale = Math.min(1, maxDim / Math.max(width, height));
                    width = Math.round(width * scale);
                    height = Math.round(height * scale);

                    const canvas = document.createElement('canvas');
                    canvas.width = width;
                    canvas.height = height;
                    const ctx = canvas.getContext('2d');
                    ctx.drawImage(img, 0, 0, width, height);

                    const imageData = ctx.getImageData(0, 0, width, height);
                    const data = imageData.data;
                    // grayscale + simple threshold
                    let sum = 0, count = 0;
                    for (let i = 0; i < data.length; i += 4) {
                        const r = data[i], g = data[i + 1], b = data[i + 2];
                        const gray = (0.299 * r + 0.587 * g + 0.114 * b);
                        sum += gray; count++;
                    }
                    const avg = sum / (count || 1);
                    const th = Math.max(120, Math.min(190, Math.round(avg + 10))); // adaptive-ish threshold
                    for (let i = 0; i < data.length; i += 4) {
                        const r = data[i], g = data[i + 1], b = data[i + 2];
                        const gray = (0.299 * r + 0.587 * g + 0.114 * b);
                        const v = gray > th ? 255 : 0;
                        data[i] = data[i + 1] = data[i + 2] = v;
                    }
                    ctx.putImageData(imageData, 0, 0);
                    const result = canvas.toDataURL('image/png');
                    debugLog('Preprocess complete', { original: { width: origW, height: origH }, processed: { width, height }, length: result.length });
                    resolve({ dataUrl: result, width, height, originalWidth: origW, originalHeight: origH });
                };
                img.onerror = function(err) {
                    debugLog('Preprocess image load error', err);
                    resolve({ dataUrl, width: 0, height: 0, originalWidth: 0, originalHeight: 0, error: 'load_failed' });
                };
                img.src = dataUrl;
            });
        }

        function cropCenterBand(dataUrl, ratio = 0.22) {
            return new Promise(resolve => {
                const img = new Image();
                img.onload = function() {
                    const h = Math.round(img.height * ratio);
                    const y = Math.max(0, Math.round((img.height - h) / 2));
                    const canvas = document.createElement('canvas');
                    canvas.width = img.width;
                    canvas.height = h;
                    const ctx = canvas.getContext('2d');
                    ctx.drawImage(img, 0, y, img.width, h, 0, 0, img.width, h);
                    resolve(canvas.toDataURL('image/png'));
                };
                img.src = dataUrl;
            });
        }

        function invertDataURL(dataUrl) {
            return new Promise(resolve => {
                const img = new Image();
                img.onload = function() {
                    const canvas = document.createElement('canvas');
                    canvas.width = img.width;
                    canvas.height = img.height;
                    const ctx = canvas.getContext('2d');
                    ctx.drawImage(img, 0, 0);
                    const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                    const data = imageData.data;
                    for (let i = 0; i < data.length; i += 4) {
                        data[i] = 255 - data[i];
                        data[i + 1] = 255 - data[i + 1];
                        data[i + 2] = 255 - data[i + 2];
                    }
                    ctx.putImageData(imageData, 0, 0);
                    resolve({ dataUrl: canvas.toDataURL('image/png'), width: img.width, height: img.height });
                };
                img.src = dataUrl;
            });
        }

        async function recognizeWithParams(imageDataUrl, overrideParams, label) {
            await ensureOcrWorker();
            const params = overrideParams ? { ...baseOcrParams, ...overrideParams } : baseOcrParams;
            await ocrWorker.setParameters(params);
            const t0 = performance.now();
            const { data } = await ocrWorker.recognize(imageDataUrl);
            const t1 = performance.now();
            const text = (data && data.text) ? data.text : '';
            const conf = (data && typeof data.confidence === 'number') ? Math.round(data.confidence) : null;
            debugLog('OCR result', { label, durationMs: Math.round(t1 - t0), conf, chars: text.length, sample: text.slice(0, 160).replace(/\n/g, ' ') });
            return { text, conf };
        }

        // Try to extract a tight bbox for a CNIC using character symbols
        function extractCnicBboxFromSymbols(symbols, regex) {
            if (!Array.isArray(symbols) || symbols.length === 0) return null;
            // Sort by y then x
            const syms = symbols
                .filter(s => s && s.text && /[0-9\-\s]/.test(s.text))
                .map(s => ({
                    ch: String(s.text),
                    x0: s.bbox?.x0 ?? s.x ?? 0,
                    y0: s.bbox?.y0 ?? s.y ?? 0,
                    x1: s.bbox?.x1 ?? ((s.x ?? 0) + (s.w ?? 0)),
                    y1: s.bbox?.y1 ?? ((s.y ?? 0) + (s.h ?? 0))
                }))
                .sort((a,b) => (a.y0 - b.y0) || (a.x0 - b.x0));

            // Cluster symbols into lines by y overlap
            const lines = [];
            for (const sym of syms) {
                const found = lines.find(line => Math.abs(line.y - sym.y0) < 12);
                if (found) {
                    found.syms.push(sym);
                    found.y = (found.y * found.n + sym.y0) / (found.n + 1);
                    found.n += 1;
                } else {
                    lines.push({ y: sym.y0, n: 1, syms: [sym] });
                }
            }
            for (const line of lines) {
                line.syms.sort((a,b) => a.x0 - b.x0);
                // Build sequences across the line
                let seq = '';
                let seqBoxes = [];
                const flush = () => {
                    if (!seq) return null;
                    const norm = seq.replace(/\s/g, '');
                    const hasPattern = regex.test(seq) || (norm.length >= 13 && /\d{13}/.test(norm));
                    if (hasPattern) {
                        const x0 = Math.min(...seqBoxes.map(b => b.x0));
                        const y0 = Math.min(...seqBoxes.map(b => b.y0));
                        const x1 = Math.max(...seqBoxes.map(b => b.x1));
                        const y1 = Math.max(...seqBoxes.map(b => b.y1));
                        return { x0, y0, x1, y1 };
                    }
                    return null;
                };
                for (const s of line.syms) {
                    const ch = s.ch;
                    if (/[0-9\-\s]/.test(ch)) {
                        seq += ch;
                        seqBoxes.push({ x0: s.x0, y0: s.y0, x1: s.x1, y1: s.y1 });
                    } else {
                        const bb = flush();
                        if (bb) return bb;
                        seq = '';
                        seqBoxes = [];
                    }
                }
                const bb = flush();
                if (bb) return bb;
            }
            return null;
        }

        // Fallback to server-side OCR when client OCR fails
        async function serverOcrFallback(file) {
            const status = document.getElementById('ocrStatus');
            try {
                if (status) { status.style.color = '#333'; status.textContent = 'Scanning on server...'; }
                const form = new FormData();
                form.append('image', file, file.name || 'cnic.png');
                const resp = await fetch('/ocr/cnic', { method: 'POST', body: form });
                debugLog('Server OCR response', { ok: resp.ok, status: resp.status });
                const json = await resp.json().catch(() => ({}));
                debugLog('Server OCR payload', json);
                if (json && json.success && json.cnic) {
                    const cnicInput = document.getElementById('cnicNumber');
                    if (cnicInput) cnicInput.value = json.cnic;
                    if (status) { status.style.color = '#228b22'; status.textContent = `CNIC detected: ${json.raw || json.cnic}`; }
                    return true;
                }
                if (status) { status.style.color = '#ef4444'; status.textContent = 'CNIC not detected. Please try again with a clearer image.'; }
                return false;
            } catch (e) {
                console.error('Server OCR error', e);
                if (status) { status.style.color = '#ef4444'; status.textContent = 'CNIC not detected. Please try again with a clearer image.'; }
                return false;
            }
        }

        // Extract and autofill CNIC from an input[type=file]
        async function handleCNICImage(fileInputEl) {
            const status = document.getElementById('ocrStatus');
            if (!fileInputEl || !fileInputEl.files || !fileInputEl.files[0]) return;
            const file = fileInputEl.files[0];
            debugLog('File selected', { name: file.name, type: file.type, sizeBytes: file.size });
            try {
                if (status) { status.style.color = '#333'; status.textContent = 'Scanning CNIC...'; }
                const dataUrl = await new Promise((resolve, reject) => {
                    const fr = new FileReader();
                    fr.onload = () => resolve(fr.result);
                    fr.onerror = reject;
                    fr.readAsDataURL(file);
                });
                debugLog('FileReader complete', { dataUrlPrefix: String(dataUrl).slice(0, 30) });
                // Attempt order: original -> preprocessed -> cropped band -> inverted cropped
                const { text: t0, conf: c0 } = await recognizeWithParams(dataUrl, { tessedit_char_whitelist: '0123456789- ', tessedit_pageseg_mode: '7' }, 'cnic_raw');
                debugLog('Client OCR confidence (raw)', c0);
                let text = t0, conf = c0;
                if (!(text && text.length)) {
                    const pre = await preprocessDataURLForOCR(dataUrl);
                    const r1 = await recognizeWithParams(pre.dataUrl || pre, { tessedit_char_whitelist: '0123456789- ', tessedit_pageseg_mode: '7' }, 'cnic');
                    text = r1.text; conf = r1.conf;
                }
                debugLog('Client OCR confidence', conf);
                const match = text && text.match(window.CNIC_REGEX);
                const cnicInput = document.getElementById('cnicNumber');
                if (match) {
                    const raw = `${match[1]}-${match[2]}-${match[3]}`;
                    const digits = `${match[1]}${match[2]}${match[3]}`;
                    if (cnicInput) cnicInput.value = digits; // field expects no dashes
                    if (status) { status.style.color = '#228b22'; status.textContent = `CNIC detected: ${raw}`; }
                } else {
                    debugLog('No match yet, trying cropped center band');
                    const band = await cropCenterBand(dataUrl, 0.22);
                    const r2 = await recognizeWithParams(band, { tessedit_char_whitelist: '0123456789- ', tessedit_pageseg_mode: '7' }, 'cnic_band');
                    const match2 = r2.text && r2.text.match(window.CNIC_REGEX);
                    if (match2) {
                        const raw = `${match2[1]}-${match2[2]}-${match2[3]}`;
                        const digits = `${match2[1]}${match2[2]}${match2[3]}`;
                        if (cnicInput) cnicInput.value = digits;
                        if (status) { status.style.color = '#228b22'; status.textContent = `CNIC detected: ${raw}`; }
                    } else {
                        debugLog('No match on band, trying inverted band');
                        const inv = await invertDataURL(band);
                        const r3 = await recognizeWithParams(inv.dataUrl || inv, { tessedit_char_whitelist: '0123456789- ', tessedit_pageseg_mode: '7' }, 'cnic_band_inverted');
                        const match3 = r3.text && r3.text.match(window.CNIC_REGEX);
                        if (match3) {
                            const raw = `${match3[1]}-${match3[2]}-${match3[3]}`;
                            const digits = `${match3[1]}${match3[2]}${match3[3]}`;
                            if (cnicInput) cnicInput.value = digits;
                            if (status) { status.style.color = '#228b22'; status.textContent = `CNIC detected: ${raw}`; }
                        } else {
                            await serverOcrFallback(file);
                        }
                    }
                }
            } catch (e) {
                console.error('OCR error', e);
                await serverOcrFallback(file);
            }
        }

        // Close camera when modal is clicked outside
        document.getElementById('cameraModal').addEventListener('click', function(e) {
            if (e.target === this) {
                closeCamera();
            }
        });

        // Update hidden input based on checkbox state
        document.getElementById('vehiclePassengersCheckbox').addEventListener('change', function() {
            document.getElementById('vehiclePassengersHidden').value = this.checked ? 'yes' : 'no';
        });

        document.getElementById('vehicleGoodsCheckbox').addEventListener('change', function() {
            document.getElementById('vehicleGoodsHidden').value = this.checked ? 'yes' : 'no';
        });

        document.getElementById('vehicleForeignCheckbox').addEventListener('change', function() {
            document.getElementById('vehicleForeignHidden').value = this.checked ? 'yes' : 'no';
            
            // Toggle visibility of foreign passenger fields
            const foreignFields = [
                document.querySelector('.number-foreign'),
                document.querySelector('.number-foreign-females'),
                document.querySelector('.number-foreign-males')
            ];
            
            foreignFields.forEach(field => {
                if (this.checked) {
                    field.classList.add('show');
                } else {
                    field.classList.remove('show');
                    // Clear the input values when hiding
                    const input = field.querySelector('input');
                    if (input) input.value = '';
                }
            });
        });

        // Remove CNIC upload OCR processing
    </script>
</html>